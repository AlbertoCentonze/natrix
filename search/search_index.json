{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Natrix","text":"<p>Natrix is a static analysis tool for Vyper contracts that helps you identify potential issues, style violations, and optimization opportunities in your smart contracts.</p>"},{"location":"#why-natrix","title":"Why Natrix?","text":"<p>Smart contracts on blockchain platforms manage valuable assets and are immutable once deployed. Static analysis helps detect potential issues before deployment, saving gas costs and preventing security vulnerabilities.</p> <p>Natrix focuses specifically on Vyper, providing tailored analysis for this smart contract language.</p>"},{"location":"#features","title":"Features","text":"<p>Natrix performs various checks on your Vyper code, including:</p> <ul> <li>Style checks (naming conventions, explicit decorators)</li> <li>Gas optimization suggestions (storage caching, memory expansion)</li> <li>Code quality warnings (unused variables and arguments)</li> <li>Security best practices</li> </ul> <p>For a complete list of rules, see the Rules section.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start using Natrix? Check out our Quick Start guide for installation and basic usage instructions.</p> <p>For advanced configuration options, see the Configuration guide.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Natrix would not be possible without the support of:</p> <ul> <li>Builder ENS Grants - For providing a grant to support the development of Natrix.</li> <li>Charles Cooper - Vyper core developer, for his invaluable help with the AST implementation and technical guidance.</li> <li>Curve Finance - For providing complex smart contract challenges that inspired the creation of this linter.</li> </ul> <p>Thank you to all contributors and supporters who have helped make this project a reality!</p>"},{"location":"CONTRIBUTING/","title":"Documentation Contribution Guidelines","text":""},{"location":"CONTRIBUTING/#adding-new-rule-documentation","title":"Adding New Rule Documentation","text":"<ol> <li>Create a new file in <code>docs/rules/&lt;rule-name&gt;.md</code></li> <li>Use this template:</li> </ol> <pre><code># Rule Name\n\n| Property | Value |\n|----------|-------|\n| Rule Code | `NTXN` |\n| Severity | Warning/Style/Optimization/Important |\n| Configuration | `param_name` - Description (default: value) |\n\n## Background\nBrief explanation of why this rule exists.\n\n## Purpose\nWhat the rule detects or enforces.\n\n## Example\n```vyper\n# Non-compliant code\n...\n\n# Compliant code\n...\n</code></pre>"},{"location":"CONTRIBUTING/#configuration","title":"Configuration","text":""},{"location":"CONTRIBUTING/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[tool.natrix.rule_configs.RuleName]\nparam = \"value\"\n</code></pre>"},{"location":"CONTRIBUTING/#command-line","title":"Command Line","text":"<p><pre><code>natrix --rule-config RuleName.param=value\n</code></pre> ```</p> <ol> <li>Important:</li> <li>Only include the Configuration section if the rule has configurable parameters</li> <li>Do not add arbitrary sections - stick to the template</li> <li> <p>Keep the structure consistent with existing rule documentation</p> </li> <li> <p>Update <code>docs/rules/index.md</code> with the new rule entry</p> </li> <li> <p>Add the rule to <code>mkdocs.yml</code> navigation:    ```yaml    nav:</p> <ul> <li>Rules:</li> <li>Rule Name (NTXN): rules/rule-name.md    ```</li> </ul> </li> <li> <p>Update <code>docs/configuration.md</code> if the rule has configurable parameters</p> </li> <li> <p>Verify the documentation builds correctly:    <code>bash    mkdocs build</code></p> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Natrix can be configured using a <code>pyproject.toml</code> file in your project root. All configuration options are placed under the <code>[tool.natrix]</code> section.</p>"},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>[tool.natrix]\n# Files or directories to lint (relative to pyproject.toml location)\nfiles = [\"contracts/\", \"tests/contracts/\"]\n\n# Rules to disable globally\ndisabled_rules = [\"NTX1\", \"NTX2\"]\n\n# Additional paths to search for imports\npath = [\"lib\", \"vendor/contracts\"]\n\n# Rule-specific configurations\n[tool.natrix.rule_configs.MemoryExpansion]\nmax_frame_size = 25000\n\n[tool.natrix.rule_configs.ArgNamingConvention]\npattern = \"^_[a-z][a-z0-9_]*$\"\n</code></pre>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"configuration/#files-to-lint","title":"Files to Lint","text":"<p>Specify which files or directories natrix should analyze:</p> <pre><code>[tool.natrix]\n# Single file\nfiles = [\"contract.vy\"]\n\n# Multiple files and directories\nfiles = [\"contracts/\", \"tests/\", \"standalone.vy\"]\n\n# Relative paths are resolved relative to pyproject.toml location\nfiles = [\"src/contracts/\", \"../shared/contracts/\"]\n</code></pre> <p>If no <code>files</code> configuration is provided, natrix will scan the current directory and all subdirectories for <code>.vy</code> files.</p>"},{"location":"configuration/#import-paths","title":"Import Paths","text":"<p>Specify additional paths where the Vyper compiler should look for imports:</p> <pre><code>[tool.natrix]\n# Single path\npath = [\"lib\"]\n\n# Multiple paths\npath = [\"lib\", \"vendor/contracts\", \"../shared\"]\n\n# Paths are resolved relative to pyproject.toml location\n</code></pre> <p>By default, natrix includes: 1. All Python system paths (same paths Python uses for imports, obtained via <code>sys.path</code>) 2. <code>lib/pypi</code> - the default dependency folder for moccasin</p> <p>Additional paths specified here will be added to these defaults.</p> <p>This is equivalent to using the <code>-p</code> flag in the command line: <pre><code>natrix contract.vy -p lib vendor/contracts ../shared\n</code></pre></p>"},{"location":"configuration/#disabling-rules","title":"Disabling Rules","text":"<p>Disable specific rules globally across your project:</p> <pre><code>[tool.natrix]\n# Disable single rule\ndisabled_rules = [\"NTX8\"]\n\n# Disable multiple rules\ndisabled_rules = [\"NTX1\", \"NTX7\", \"NTX11\"]\n</code></pre> <p>You can find all available rule codes by running: <pre><code>natrix --list-rules\n</code></pre></p>"},{"location":"configuration/#rule-specific-configuration","title":"Rule-Specific Configuration","text":"<p>Some rules accept configuration parameters to customize their behavior. Only two rules currently have configurable parameters:</p> <p>Memory Expansion Rule (NTX1) <pre><code>[tool.natrix.rule_configs.MemoryExpansion]\nmax_frame_size = 25000  # Default: 20000\n</code></pre></p> <p>Argument Naming Convention Rule (NTX11) <pre><code>[tool.natrix.rule_configs.ArgNamingConvention]\npattern = \"^_[a-z][a-z0-9_]*$\"  # Default: \"^_\"\n</code></pre></p> <p>For detailed configuration examples and advanced usage, see the individual rule documentation pages in the Rules section.</p>"},{"location":"configuration/#json-output-mode","title":"JSON Output Mode","text":"<p>Natrix supports JSON output for programmatic integration with IDEs, CI/CD pipelines, and other development tools.</p> <p>Enable JSON output with the <code>--json</code> flag:</p> <pre><code>natrix contract.vy --json\n</code></pre> <p>This outputs issues as a JSON array instead of the default colored terminal output, making it easy to parse and process results programmatically.</p>"},{"location":"configuration/#example-configurations","title":"Example Configurations","text":"DeFi ProtocolLearning ProjectMinimal <pre><code>[tool.natrix]\nfiles = [\"contracts/core/\", \"contracts/interfaces/\", \"tests/unit/\"]\npath = [\"lib/snekmate\", \"lib/vyper-utils\"]\ndisabled_rules = [\"NTX7\"]\n\n[tool.natrix.rule_configs.MemoryExpansion]\nmax_frame_size = 15000\n\n[tool.natrix.rule_configs.ArgNamingConvention]\npattern = \"^_[a-z][a-z0-9_]*$\"\n</code></pre> <pre><code>[tool.natrix]\nfiles = [\"contracts/\", \"examples/\"]\ndisabled_rules = [\"NTX7\"]\n\n[tool.natrix.rule_configs.MemoryExpansion]\nmax_frame_size = 35000\n</code></pre> <pre><code>[tool.natrix]\ndisabled_rules = [\"NTX7\"]\n</code></pre>"},{"location":"metadata-limitations/","title":"Metadata Limitations","text":""},{"location":"metadata-limitations/#overview","title":"Overview","text":"<p>Some Natrix rules rely on metadata output from the Vyper compiler. However, files using deferred module initialization cannot generate metadata.</p>"},{"location":"metadata-limitations/#deferred-module-initialization","title":"Deferred Module Initialization","text":"<p>When a Vyper file uses the <code>uses:</code> statement for deferred initialization, the compiler cannot generate metadata. This is because module initialization constraints are validated after AST generation but before code generation (where metadata is produced).</p> <p>For more details about the <code>uses:</code> statement, see the Vyper documentation.</p>"},{"location":"metadata-limitations/#affected-rules","title":"Affected Rules","text":"<ul> <li>Memory Expansion (NTX1): Cannot analyze function frame sizes without metadata</li> </ul>"},{"location":"metadata-limitations/#impact","title":"Impact","text":"<p>For files using deferred initialization: - AST-based rules work normally - Metadata-dependent rules are silently skipped</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This guide will help you get up and running with Natrix quickly.</p>"},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python (version 3.10 or higher)</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>You can install Natrix using various package managers:</p> pipuvpoetry <pre><code>pip install natrix\n</code></pre> <pre><code>uv add natrix\n</code></pre> <pre><code>poetry add natrix\n</code></pre>"},{"location":"quick-start/#usage","title":"Usage","text":"<p>To analyze a Vyper contract:</p> <pre><code>natrix lint path/to/your/contract.vy\n# or simply\nnatrix path/to/your/contract.vy\n</code></pre> <p>You can also analyze multiple files at once:</p> <pre><code>natrix lint path/to/contracts/\n# or simply\nnatrix path/to/contracts/\n</code></pre>"},{"location":"quick-start/#code-generation","title":"Code Generation","text":"<p>Natrix includes code generation utilities to help with various tasks:</p>"},{"location":"quick-start/#generate-explicit-exports","title":"Generate Explicit Exports","text":"<p>Generate explicit exports for a contract to fix the implicit export warning:</p> <pre><code>natrix codegen exports path/to/your/contract.vy\n</code></pre>"},{"location":"quick-start/#generate-call-graph","title":"Generate Call Graph","text":"<p>Visualize the function call relationships in your contract using Mermaid diagrams:</p> <pre><code># Generate call graph for entire contract\nnatrix codegen call_graph path/to/your/contract.vy\n\n# Generate call graph for a specific function and its dependencies\nnatrix codegen call_graph path/to/your/contract.vy:function_name\n</code></pre> <p>The call graph generator will output a Mermaid diagram that shows: - All functions in your contract - Which functions call which other functions - External calls to other contracts (e.g., <code>AMM.withdraw</code>)</p> <p>Example output: <pre><code>%%{init: {\n  \"flowchart\": {\n    \"nodeSpacing\": 100,\n    \"rankSpacing\": 400\n  }\n}}%%\nflowchart TD\n    N0[\"repay\"]\n    N1[\"_debt\"]\n    N2[\"AMM.withdraw\"]\n    N0 --&gt; N1\n    N0 --&gt; N2\n</code></pre></p> <p>You can copy this output to any Mermaid-compatible viewer to visualize your contract's structure.</p>"},{"location":"quick-start/#integration-with-pre-commit","title":"Integration with pre-commit","text":"<p>You can use Natrix with pre-commit to automatically lint your Vyper files before each commit.</p> <ol> <li>Add a <code>.pre-commit-config.yaml</code> file to your project with the following content:</li> </ol> <pre><code>repos:\n- repo: https://github.com/AlbertoCentonze/natrix\nrev: v0.1.9  # Use the latest version\nhooks:\n    - id: natrix\n</code></pre> <ol> <li>Install the hooks:</li> </ol> <pre><code>pre-commit install\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>For advanced configuration options, see the Configuration guide</li> <li>Explore the available Rules to understand what Natrix can check for</li> <li>Learn more about Development if you want to contribute</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section provides an overview of the Natrix API for developers creating custom rules or integrating Natrix into other tools.</p>"},{"location":"api/#core-architecture","title":"Core Architecture","text":"<p>Natrix is built around several key abstractions that provide an unstable API for rule development:</p>"},{"location":"api/#ast-processing-pipeline","title":"AST Processing Pipeline","text":"<ol> <li>Vyper Compilation: Compile <code>.vy</code> files to annotated AST</li> <li>Node Wrapping: Wrap raw AST in <code>Node</code> objects for easy traversal</li> <li>Rule Application: Apply registered rules using the visitor pattern</li> <li>Issue Collection: Gather and format rule violations</li> </ol>"},{"location":"api/#output-formats","title":"Output Formats","text":"<p>Natrix supports multiple output formats:</p> <ul> <li>CLI Output: Colored terminal output with source code snippets (default)</li> <li>JSON Output: Machine-readable format for programmatic integration</li> </ul> <p>Use the <code>--json</code> flag to enable JSON output, which returns an array of issue objects suitable for IDE integration, CI/CD pipelines, or other automated tools.</p>"},{"location":"api/#node-api","title":"Node API","text":"<p>The <code>Node</code> class is the primary abstraction for working with Vyper AST data. It is inspired by the <code>VyperNode</code> class but adapted to work with json AST data.</p>"},{"location":"api/#basic-node-operations","title":"Basic Node Operations","text":"<pre><code>from natrix.ast_node import Node\n\n# Create a node from AST data\nnode = Node(ast_dict)\n\n# Access node properties safely\nnode_type = node.get(\"ast_type\")\nfunction_name = node.get(\"name\", default=\"unknown\")\n\n# Navigate the AST tree\nparent = node.parent\nchildren = node.children\n</code></pre>"},{"location":"api/#node-traversal-methods","title":"Node Traversal Methods","text":"<p>This methods are inspired from the vyper</p>"},{"location":"api/#get_descendantsnode_typenone-filtersnone-include_selffalse-reversefalse","title":"<code>get_descendants(node_type=None, filters=None, include_self=False, reverse=False)</code>","text":"<p>Find all descendant nodes matching criteria:</p> <pre><code># Find all function definitions\nfunctions = root.get_descendants(\"FunctionDef\")\n\n# Find nodes with specific properties\nassigns = root.get_descendants(\"Assign\", filters={\"target.id\": \"total\"})\n\n# Multiple node types\ncontrol_flow = root.get_descendants((\"If\", \"For\", \"While\"))\n</code></pre>"},{"location":"api/#get_childrennode_typenone-filtersnone-reversefalse","title":"<code>get_children(node_type=None, filters=None, reverse=False)</code>","text":"<p>Find immediate children only:</p> <pre><code># Get all direct children of a specific type\nstatements = function_node.get_children(\"Expr\")\n</code></pre>"},{"location":"api/#get_ancestornode_typenone","title":"<code>get_ancestor(node_type=None)</code>","text":"<p>Find parent nodes:</p> <pre><code># Find the containing function\ncontaining_function = node.get_ancestor(\"FunctionDef\")\n\n# Find any ancestor matching types\ncontainer = node.get_ancestor((\"FunctionDef\", \"For\", \"If\"))\n</code></pre>"},{"location":"api/#property-access-with-get","title":"Property Access with <code>get()</code>","text":"<p>Safely access nested properties using dot notation:</p> <pre><code># Simple property access\nline_number = node.get(\"lineno\")\n\n# Nested property access\ntarget_name = node.get(\"target.id\")\ndecorator_name = node.get(\"decorator_list.0.id\")\n\n# With default values\nnode_name = node.get(\"name\", default=\"anonymous\")\n</code></pre>"},{"location":"api/#functiondefnode-api","title":"FunctionDefNode API","text":"<p>Specialized subclass for function definitions with additional properties:</p> <pre><code>from natrix.ast_node import FunctionDefNode\n\n# Cast or create FunctionDefNode\nif node.ast_type == \"FunctionDef\":\n    func_node = FunctionDefNode(node.node_dict, parent=node.parent)\n</code></pre>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#modifiers-liststr","title":"<code>modifiers: List[str]</code>","text":"<p>Get function decorators:</p> <pre><code># Returns list like [\"external\", \"view\", \"nonreentrant\"]\ndecorators = func_node.modifiers\n\n# Check for specific modifiers\nis_external = \"external\" in func_node.modifiers\nis_view = \"view\" in func_node.modifiers\n</code></pre>"},{"location":"api/#is_constructor-bool","title":"<code>is_constructor: bool</code>","text":"<p>Check if function is a constructor:</p> <pre><code>if func_node.is_constructor:\n    # Handle constructor logic\n    pass\n</code></pre>"},{"location":"api/#is_from_interface-bool","title":"<code>is_from_interface: bool</code>","text":"<p>Check if function is from an interface definition:</p> <pre><code>if func_node.is_from_interface:\n    # Skip interface functions\n    return\n</code></pre>"},{"location":"api/#memory_accesses-listmemoryaccess","title":"<code>memory_accesses: List[MemoryAccess]</code>","text":"<p>Get all memory read/write operations:</p> <pre><code>for access in func_node.memory_accesses:\n    print(f\"{access.type}: {access.var}\")  # \"read: balance\"\n</code></pre>"},{"location":"api/#called_functions-liststr","title":"<code>called_functions: List[str]</code>","text":"<p>Get all functions called by this function:</p> <pre><code># Returns list of function names, including external calls\ncalls = func_node.called_functions\n# Example: [\"_debt\", \"AMM.withdraw\", \"transferFrom\"]\n\n# Deduplicated - each function appears only once\n</code></pre>"},{"location":"api/#modulenode-api","title":"ModuleNode API","text":"<p>Specialized subclass for module (top-level) nodes with call graph functionality:</p> <pre><code>from natrix.ast_node import ModuleNode\n\n# The root node from parsing is automatically a ModuleNode\nif isinstance(root, ModuleNode):\n    functions = root.functions\n    call_graph = root.call_graph\n</code></pre>"},{"location":"api/#properties_1","title":"Properties","text":""},{"location":"api/#functions-listfunctiondefnode","title":"<code>functions: List[FunctionDefNode]</code>","text":"<p>Get all function definitions in the module:</p> <pre><code># Returns all FunctionDef nodes as FunctionDefNode instances\nfor func in module.functions:\n    print(f\"Function: {func.get('name')}\")\n</code></pre>"},{"location":"api/#call_graph-dictstr-liststr","title":"<code>call_graph: Dict[str, List[str]]</code>","text":"<p>Get the complete call graph for the module:</p> <pre><code># Returns a dictionary mapping function names to their called functions\ngraph = module.call_graph\n# Example: {\"repay\": [\"_debt\", \"AMM.withdraw\"], \"_debt\": [\"AMM.get_rate_mul\"]}\n\n# Use for analysis or visualization\nfor func, calls in graph.items():\n    print(f\"{func} calls: {', '.join(calls)}\")\n\n## Project Context API\n\nThe `ProjectContext` class manages the dependency graph and compilation of all modules in a project:\n\n```python\nfrom pathlib import Path\nfrom natrix.context import ProjectContext\n\n# Create context with all project files\nvy_files = [Path(\"contract1.vy\"), Path(\"contract2.vy\")]\ncontext = ProjectContext(vy_files, extra_paths=(Path(\"lib\"),))\n\n# Get module information\nmodule = context.get_module(Path(\"contract1.vy\"))\nif module:\n    print(f\"Dependencies: {module.dependencies}\")\n    print(f\"Dependents: {module.dependents}\")\n\n# Get dependency relationships\ndeps = context.get_dependencies_of(Path(\"contract1.vy\"))\ndependents = context.get_dependents_of(Path(\"contract1.vy\"))\n</code></pre>"},{"location":"api/#rule-development-api","title":"Rule Development API","text":""},{"location":"api/#base-rule-class","title":"Base Rule Class","text":"<p>All rules inherit from <code>BaseRule</code>:</p> <pre><code>from natrix.rules.common import BaseRule, RuleRegistry\nfrom natrix.ast_node import Node\n\n@RuleRegistry.register\nclass MyRule(BaseRule):\n    CODE = \"NTX999\"  # Unique rule identifier\n    MESSAGE = \"Following pattern is not allowed: {}\"  # Format string for messages\n\n    def __init__(self, custom_param=\"default\"):\n        super().__init__(\n            severity=\"warning\",  # \"error\", \"warning\", \"info\"\n            code=self.CODE,\n            message=self.MESSAGE,\n        )\n        self.custom_param = custom_param\n</code></pre>"},{"location":"api/#visitor-methods","title":"Visitor Methods","text":"<p>Implement visitor methods for specific AST node types:</p> <pre><code>class MyRule(BaseRule):\n    def visit_FunctionDef(self, node):\n        \"\"\"Called for every function definition\"\"\"\n        if self._should_flag(node):\n            self.add_issue(node, \"Function violates rule\")\n\n    def visit_Assign(self, node):\n        \"\"\"Called for every assignment\"\"\"\n        pass\n\n    def visit_Name(self, node):\n        \"\"\"Called for every name reference\"\"\"\n        pass\n</code></pre>"},{"location":"api/#issue-reporting","title":"Issue Reporting","text":""},{"location":"api/#add_issuenode-message_args","title":"<code>add_issue(node, *message_args)</code>","text":"<p>Report a rule violation:</p> <pre><code>def visit_FunctionDef(self, node):\n    function_name = node.get(\"name\")\n    if len(function_name) &gt; 50:\n        # Message formatting with arguments\n        self.add_issue(node, function_name, len(function_name))\n</code></pre>"},{"location":"api/#rule-registration","title":"Rule Registration","text":""},{"location":"api/#manual-registration","title":"Manual Registration","text":"<pre><code>from natrix.rules.common import RuleRegistry\n\n# Register a rule class\nRuleRegistry.register(MyRule)\n</code></pre>"},{"location":"api/#decorator-registration","title":"Decorator Registration","text":"<pre><code>@RuleRegistry.register  # Recommended approach\nclass MyRule(BaseRule):\n    pass\n</code></pre>"},{"location":"api/#code-generation-api","title":"Code Generation API","text":"<p>Utilities for generating code from Vyper contracts:</p> <pre><code>from pathlib import Path\nfrom natrix.codegen import generate_exports, generate_call_graph\n\n# Generate explicit exports for a contract\nexports = generate_exports(Path(\"contract.vy\"), extra_paths=())\nprint(exports)\n# Output:\n# # NOTE: Always double-check the generated exports\n# exports: (\n#     Contract.transfer,\n#     Contract.balanceOf\n# )\n\n# Generate call graph for entire contract\ncall_graph = generate_call_graph(Path(\"contract.vy\"), extra_paths=())\nprint(call_graph)  # Mermaid diagram output\n\n# Generate call graph for specific function\ncall_graph = generate_call_graph(\n    Path(\"contract.vy\"),\n    extra_paths=(),\n    target_function=\"repay\"\n)\n</code></pre>"},{"location":"api/#ast-tools-api","title":"AST Tools API","text":"<p>Utilities for working with Vyper compilation:</p> <pre><code>from pathlib import Path\nfrom natrix.ast_tools import parse_file, vyper_compile, VyperASTVisitor\nfrom natrix.ast_node import Node\n\n# Parse a Vyper file to AST\nast_data = parse_file(Path(\"contract.vy\"))\nroot_node = Node(ast_data[\"ast\"])\n\n# Compile with specific format\nast_only = vyper_compile(Path(\"contract.vy\"), \"annotated_ast\")\nmetadata = vyper_compile(Path(\"contract.vy\"), \"metadata\")\n</code></pre>"},{"location":"api/#vyperastvisitor","title":"VyperASTVisitor","text":"<p>Base visitor for traversing AST nodes:</p> <pre><code>class MyVisitor(VyperASTVisitor):\n    def visit_FunctionDef(self, node):\n        print(f\"Found function: {node.get('name')}\")\n\n    def visit_Assign(self, node):\n        print(f\"Assignment at line {node.get('lineno')}\")\n\n# Use the visitor\nvisitor = MyVisitor()\nvisitor.visit(root_node)\n</code></pre>"},{"location":"api/#configuration-api","title":"Configuration API","text":""},{"location":"api/#rule-configuration","title":"Rule Configuration","text":"<p>Rules can accept configuration parameters:</p> <pre><code>class ConfigurableRule(BaseRule):\n    def __init__(self, threshold=100, pattern=\"^_\"):\n        super().__init__()\n        self.threshold = threshold\n        self.pattern = re.compile(pattern)\n</code></pre> <p>Configuration is passed via: - TOML files: <code>[tool.natrix.rule_configs.ConfigurableRule]</code> - CLI arguments: <code>--rule-config ConfigurableRule.threshold=200</code></p>"},{"location":"api/#creating-rules","title":"Creating Rules","text":""},{"location":"api/#step-by-step-example","title":"Step-by-Step Example","text":"<p>This examples shows how to apply a rule that at enforces function naming to be in <code>snake_case</code>.</p> <pre><code>from natrix.rules.common import BaseRule, RuleRegistry\nfrom natrix.ast_node import FunctionDefNode\nimport re\n\n@RuleRegistry.register\nclass FunctionNamingRule(BaseRule):\n    \"\"\"\n    Enforces function naming conventions.\n\n    Functions should use snake_case naming.\n    \"\"\"\n\n    CODE = \"NTX100\"\n    MESSAGE = \"Function '{}' should use snake_case naming\"\n\n    def __init__(self, pattern=r\"^[a-z_][a-z0-9_]*$\"):\n        super().__init__(\n            severity=\"warning\",\n            code=self.CODE,\n            message=self.MESSAGE,\n        )\n        self.pattern = re.compile(pattern)\n\n    def visit_FunctionDef(self, node: FunctionDefNode):\n        # Skip interface functions\n        if node.is_from_interface:\n            return\n\n        function_name = node.get(\"name\")\n\n        # Skip special functions\n        if function_name.startswith(\"__\"):\n            return\n\n        if not self.pattern.match(function_name):\n            self.add_issue(node, function_name)\n</code></pre>"},{"location":"api/#testing-rules","title":"Testing Rules","text":"<pre><code>import pytest\nfrom pathlib import Path\nfrom natrix.context import ProjectContext\nfrom natrix.ast_tools import parse_file\nfrom natrix.ast_node import Node\n\ndef test_function_naming_rule():\n    # Create test contract\n    test_contract = \"\"\"\n@external\ndef badFunctionName():  # Should trigger rule\n    pass\n\n@external\ndef good_function_name():  # Should pass\n    pass\n\"\"\"\n\n    # Parse and test\n    test_path = Path(\"test.vy\")\n    with open(test_path, \"w\") as f:\n        f.write(test_contract)\n\n    # Create context and run rule\n    context = ProjectContext([test_path])\n    rule = FunctionNamingRule()\n    issues = rule.run(context, test_path)\n\n    assert len(issues) == 1\n    assert \"badFunctionName\" in issues[0].message\n</code></pre>"},{"location":"api/#best-practices","title":"Best Practices","text":""},{"location":"api/#performance","title":"Performance","text":"<ul> <li>Cache expensive operations using <code>@cached_property</code></li> <li>Use specific visitor methods instead of generic traversal</li> <li>Filter early with node type and filter parameters</li> </ul>"},{"location":"api/#robustness","title":"Robustness","text":"<ul> <li>Use <code>node.get()</code> with defaults for safe property access</li> <li>Check node types before casting to specialized classes</li> <li>Handle missing AST properties gracefully</li> </ul>"},{"location":"api/#maintainability","title":"Maintainability","text":"<ul> <li>Use descriptive rule codes and messages</li> <li>Document rule behavior in docstrings</li> <li>Provide configuration options for flexibility</li> <li>Include comprehensive tests</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This section provides information for developers contributing to Natrix.</p>"},{"location":"development/#python-version","title":"Python Version","text":"<p>Natrix requires Python 3.10 or higher. This is specified in <code>pyproject.toml</code>: <pre><code>requires-python = \"&gt;=3.10\"\n</code></pre></p>"},{"location":"development/#uv-package-manager","title":"UV Package Manager","text":"<p>Natrix uses UV for dependency management and development workflows.</p>"},{"location":"development/#vyper-compiler","title":"Vyper Compiler","text":"<p>Natrix supports Vyper compiler versions 0.4.0 and above.</p>"},{"location":"development/#creating-a-new-rule","title":"Creating a New Rule","text":"<p>See the API Reference for detailed information on implementing new rules.</p>"},{"location":"development/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Report bugs or request features on GitHub Issues</li> <li>Discussions: Ask questions on Vyperholics</li> </ul>"},{"location":"rules/","title":"Rules","text":"<p>This section documents the available rules in Natrix.</p> Rule Code Name Severity Description NTX1 Memory Expansion Warning Detects when a function's memory frame size is too large NTX2 Constant Naming Convention Style Ensures that constants are named in <code>UPPER_SNAKE_CASE</code> NTX3 Implicit Internal Style Detects when internal functions are missing the <code>@internal</code> decorator NTX4 Implicit View Style Detects when view functions are missing the <code>@view</code> decorator NTX5 Implicit Pure Style Detects when pure functions are missing the <code>@pure</code> decorator NTX6 Print Left Warning Detects when <code>print</code> statements are left in the code NTX7 Cache Storage Variable Optimization Detects when a storage variable is accessed multiple times and suggests caching NTX8 Unused Variable Warning Detects variables that are declared but never used NTX9 Implicit Export Important Detects when a module exposes all its functions using <code>__interface__</code> NTX10 Unused Argument Warning Detects function arguments that are declared but never used NTX11 Argument Naming Convention Warning Ensures function arguments follow a specified naming convention NTX12 Modifiers Ordering Style Enforces consistent ordering of function modifiers NTX13 Unused Event Warning Detects events that are defined but never emitted NTX14 Unused Imports Warning Detects imports that are defined but never used"},{"location":"rules/#rule-categories","title":"Rule Categories","text":"<p>Rules are categorized by severity:</p> <ul> <li>Style: Suggestions to improve code readability and consistency.</li> <li>Warning: Potential issues that could lead to bugs or inefficiencies.</li> <li>Optimization: Suggestions to improve gas efficiency.</li> <li>Important: Issues that could have significant impact on security or correctness.</li> </ul>"},{"location":"rules/argument-naming/","title":"Argument Naming Convention","text":"Property Value Rule Code <code>NTX11</code> Severity Warning Configuration <code>pattern</code> - Regex pattern for argument naming convention (default: <code>^_</code>)"},{"location":"rules/argument-naming/#background","title":"Background","text":"<p>Consistent naming conventions improve code readability and maintainability. Prefixing arguments (e.g., with <code>_</code>) can help distinguish them from local variables or state variables at a glance.</p>"},{"location":"rules/argument-naming/#purpose","title":"Purpose","text":"<p>Ensures that function arguments follow a specified naming convention. By default, arguments should start with an underscore (<code>_</code>).</p>"},{"location":"rules/argument-naming/#example","title":"Example","text":"<p>Consider the following Vyper code:</p> <pre><code># Non-compliant - argument 'arg1' does not start with '_'\n@external\ndef myFunction(arg1: uint256, _arg2: String[10]):\n    pass\n\n# Compliant\n@external\ndef anotherFunction(_input_value: address, _another_param: bool):\n    pass\n</code></pre> <p>In the <code>myFunction</code> example, <code>arg1</code> would be flagged by this rule because it does not start with an underscore. <code>_arg2</code> is compliant. In <code>anotherFunction</code>, both arguments <code>_input_value</code> and <code>_another_param</code> are compliant.</p>"},{"location":"rules/argument-naming/#configuration","title":"Configuration","text":"<p>This rule can be customized by adjusting the naming pattern:</p> <ul> <li><code>pattern</code> (string): Regular expression pattern that argument names must match (default: <code>^_</code>)</li> </ul>"},{"location":"rules/argument-naming/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[tool.natrix.rule_configs.ArgumentNaming]\npattern = \"^_\"  # Default: Arguments must start with underscore\n</code></pre>"},{"location":"rules/argument-naming/#command-line-configuration","title":"Command Line Configuration","text":"<pre><code># Use snake_case for arguments\nnatrix --rule-config ArgumentNaming.pattern=\"^[a-z_][a-z0-9_]*$\"\n</code></pre>"},{"location":"rules/argument-naming/#class-instantiation","title":"Class Instantiation","text":"<pre><code># Require camelCase for arguments\nArgumentNamingRule(pattern=\"^[a-z][a-zA-Z0-9]*$\")\n</code></pre>"},{"location":"rules/constant-naming/","title":"Constant Naming Convention","text":"Property Value Rule Code <code>NTX2</code> Severity Style"},{"location":"rules/constant-naming/#background","title":"Background","text":"<p>Using <code>UPPER_SNAKE_CASE</code> for constants is a widely adopted convention that improves code readability by making it easy to distinguish constants from other variables.</p>"},{"location":"rules/constant-naming/#purpose","title":"Purpose","text":"<p>Ensures that constants are named in <code>UPPER_SNAKE_CASE</code>.</p>"},{"location":"rules/constant-naming/#example","title":"Example","text":"<p>Consider the following Vyper code:</p> <pre><code># Non-compliant - constant 'threshold_value' is not in UPPER_SNAKE_CASE\nthreshold_value: constant(uint256) = 1000\n\n# Compliant\nMAX_VALUE: constant(uint256) = 1000\nTOTAL_SUPPLY: constant(uint256) = 100000\n</code></pre> <p>In this example, <code>threshold_value</code> would be flagged by the rule. <code>MAX_VALUE</code> and <code>TOTAL_SUPPLY</code> are compliant.</p>"},{"location":"rules/implicit-export/","title":"Implicit Export","text":"Property Value Rule Code <code>NTX9</code> Severity Important"},{"location":"rules/implicit-export/#background","title":"Background","text":"<p>Explicitly listing exported functions improves code clarity and reduces the risk of unintentionally exposing internal functions. It makes the contract's public interface clear and well-defined.</p>"},{"location":"rules/implicit-export/#purpose","title":"Purpose","text":"<p>Detects when a module exposes all its functions using the <code>__interface__</code> expression without explicitly listing them.</p>"},{"location":"rules/implicit-export/#example","title":"Example","text":"<p>Consider you have a module <code>erc20.vy</code>:</p> <pre><code># erc20\n\n\n@external\ndef transfer():\n    # ... does something ...\n    pass\n\n@external\ndef mint():\n    # ... does something else ...\n    pass\n</code></pre> <p>And you import it in another contract:</p> <pre><code># my_token.vy\nimport erc20\n\n# Non-compliant - exposes all functions from MyHelperFunctions, including potentially _internal_logic\nexports: (erc20.__interface__) # this also exposes the function to mint, which might not always be intended\n</code></pre> <pre><code># my_token.vy\nimport erc20\n\n# Compliant - explicitly lists the functions to be exposed\nexports: (erc20.transfer, erc20.mint) # you can clearly tell that you are exposing a function to mint\n</code></pre>"},{"location":"rules/implicit-export/#automatic-fix","title":"Automatic Fix","text":"<p>Natrix can automatically generate the explicit exports for you. Simply run:</p> <pre><code>natrix codegen exports path/to/erc20.vy\n</code></pre> <p>This will output the explicit exports declaration that you can copy into your contract.</p>"},{"location":"rules/implicit-internal/","title":"Implicit Internal","text":"Property Value Rule Code <code>NTX3</code> Severity Style"},{"location":"rules/implicit-internal/#background","title":"Background","text":"<p>Since Vyper 0.4.0 functions without a visibility modifier will be marked as <code>internal</code>. Explicitly marking functions as <code>@internal</code> improves code clarity.</p>"},{"location":"rules/implicit-internal/#purpose","title":"Purpose","text":"<p>Detects when internal functions are missing the <code>@internal</code> decorator.</p>"},{"location":"rules/implicit-internal/#example","title":"Example","text":"<pre><code># Non-compliant - function is internal but not marked with @internal\ndef helper_function(x: uint256) -&gt; uint256:\n    return x * 2\n\n# Compliant\n@internal\ndef _helper_function(x: uint256) -&gt; uint256:\n    return x * 2\n</code></pre> <p>The <code>helper_function</code> would be flagged by this rule because it's not explicitly marked as <code>@internal</code>. The <code>_helper_function</code> is compliant.</p>"},{"location":"rules/implicit-pure/","title":"Implicit Pure","text":"Property Value Rule Code <code>NTX5</code> Severity Style"},{"location":"rules/implicit-pure/#background","title":"Background","text":"<p>Similar to the implicit view rule. Using the <code>@pure</code> decorator for functions that don't access state is not enforced by the compiler, but helps querying the function off-chain and helps preventing the introduction of side effects in the function.</p>"},{"location":"rules/implicit-pure/#purpose","title":"Purpose","text":"<p>Detects when functions that don't access state at all are missing the <code>@pure</code> decorator.</p>"},{"location":"rules/implicit-pure/#example","title":"Example","text":"<pre><code># Non-compliant - function doesn't access state but isn't marked as @pure\n@external\ndef calculate_sum(_a: uint256, _b: uint256) -&gt; uint256:\n    return _a + _b\n\n# Compliant\n@pure\n@external\ndef calculate_sum_pure(_a: uint256, _b: uint256) -&gt; uint256:\n    return _a + _b\n</code></pre> <p>The first <code>calculate_sum</code> function would be flagged by this rule because it doesn't access state at all but is not marked as <code>@pure</code>.</p>"},{"location":"rules/implicit-view/","title":"Implicit View","text":"Property Value Rule Code <code>NTX4</code> Severity Style"},{"location":"rules/implicit-view/#background","title":"Background","text":"<p>The compiler does not enforce functions that only read the state to be marked as <code>@view</code>. However omitting the modifier on a getter that is intended to be called off-chain forces you to execute an onchain transaction to query its value.</p>"},{"location":"rules/implicit-view/#purpose","title":"Purpose","text":"<p>Detects when functions that only read state (but don't modify it) are missing the <code>@view</code> decorator.</p>"},{"location":"rules/implicit-view/#example","title":"Example","text":"<pre><code># Storage variable\nuser_balance: public(uint256)\n\n# Non-compliant - function reads state but isn't marked as @view\n@external\ndef get_balance() -&gt; uint256:\n    return self.user_balance\n\n# Compliant\n@view\n@external\ndef get_balance_view() -&gt; uint256:\n    return self.user_balance\n</code></pre> <p>The first <code>get_balance</code> function would be flagged by this rule because it reads contract state (<code>self.user_balance</code>) but is not marked as <code>@view</code>.</p>"},{"location":"rules/memory-expansion/","title":"Memory Expansion","text":"Property Value Rule Code <code>NTX1</code> Severity Warning Configuration <code>max_frame_size</code> - Maximum allowed frame size in bytes (default: 20,000) <p>Metadata Requirement</p> <p>This rule requires compiler metadata to analyze frame sizes. It cannot check files that use deferred module initialization (<code>uses:</code> statement). See Metadata Limitations for details.</p>"},{"location":"rules/memory-expansion/#background","title":"Background","text":"<p>Vyper can only pass arguments by value. When a DynArray is passed as an argument in an external function, the amount of memory allocated will be the upper bound of the array size, and not its actual size, which can lead to unexpected memory expansion (and crazy gas costs) if arrays (even small) with large bounds are passed.</p>"},{"location":"rules/memory-expansion/#purpose","title":"Purpose","text":"<p>Detects when a function's memory frame size is too large (by default, over 20,000 bytes).</p>"},{"location":"rules/memory-expansion/#example","title":"Example","text":"<pre><code># Non-compliant - large array passed by value can cause memory expansion issues\n@external\ndef process_large_array(_data: DynArray[uint256, 100_000_000]) -&gt; uint256:\n    _sum: uint256 = 0\n    for i: uint256 in range(1000):\n        _sum += _data[i]\n    return _sum\n</code></pre> <p>The <code>process_large_array</code> function can be flagged by this rule if the memory frame size exceeds the threshold. To avoid this issue, consider passing arrays with smaller bounds until vyper implements runtime allocation for arrays.</p>"},{"location":"rules/memory-expansion/#configuration","title":"Configuration","text":"<p>This rule can be customized by adjusting the maximum frame size threshold:</p> <ul> <li><code>max_frame_size</code> (integer): Maximum allowed frame size in bytes (default: 20,000)</li> </ul>"},{"location":"rules/memory-expansion/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[tool.natrix.rule_configs.MemoryExpansion]\nmax_frame_size = 25000\n</code></pre>"},{"location":"rules/memory-expansion/#command-line-configuration","title":"Command Line Configuration","text":"<pre><code># Override threshold for a single run\nnatrix --rule-config MemoryExpansion.max_frame_size=25000\n</code></pre>"},{"location":"rules/memory-expansion/#class-instantiation","title":"Class Instantiation","text":"<pre><code># Custom threshold of 10,000 bytes\nMemoryExpansionRule(max_frame_size=10_000)\n</code></pre>"},{"location":"rules/modifiers-ordering/","title":"Modifiers Ordering","text":"Property Value Rule Code <code>NTX12</code> Severity Style"},{"location":"rules/modifiers-ordering/#background","title":"Background","text":"<p>Vyper allows multiple decorators on functions to specify visibility (@external, @internal, @deploy), mutability (@pure, @view, @nonpayable, @payable), and security properties (@nonreentrant, @reentrant). While the compiler accepts these decorators in any order, maintaining a consistent ordering improves code readability and makes the function's properties immediately clear to readers.</p>"},{"location":"rules/modifiers-ordering/#purpose","title":"Purpose","text":"<p>Enforces a consistent ordering of function modifiers in Vyper contracts. The recommended order is:</p> <ol> <li>Visibility decorators first (@external, @internal, @deploy)</li> <li>Mutability decorators second (@pure, @view, @nonpayable, @payable)</li> <li>Security decorators last (@nonreentrant)</li> </ol>"},{"location":"rules/modifiers-ordering/#example","title":"Example","text":"<pre><code># Non-compliant - incorrect ordering\n@view\n@external  # visibility should come before mutability\ndef get_balance() -&gt; uint256:\n    return self.balance\n\n@nonreentrant\n@external  # visibility should come before security\n@payable\ndef deposit():\n    self.balance += msg.value\n\n# Compliant - correct ordering\n@external  # visibility first\n@view      # mutability second\ndef get_balance_correct() -&gt; uint256:\n    return self.balance\n\n@external     # visibility first\n@payable      # mutability second\n@nonreentrant # security last\ndef deposit_correct():\n    self.balance += msg.value\n\n# Functions without explicit visibility (defaults to internal)\n# Non-compliant\n@nonreentrant\n@view  # mutability should come before security\ndef internal_func() -&gt; uint256:\n    return self.balance\n\n# Compliant\n@view         # mutability first\n@nonreentrant # security second\ndef internal_func_correct() -&gt; uint256:\n    return self.balance\n</code></pre>"},{"location":"rules/print-left/","title":"Print Left","text":"Property Value Rule Code <code>NTX6</code> Severity Warning"},{"location":"rules/print-left/#background","title":"Background","text":"<p><code>print</code> statements are typically used for debugging and should be removed from production code. They can increase gas costs and don't serve any functional purpose in a deployed contract.</p>"},{"location":"rules/print-left/#purpose","title":"Purpose","text":"<p>Detects when <code>print</code> statements are left in the code.</p>"},{"location":"rules/print-left/#example","title":"Example","text":"<pre><code>@external\ndef debug_function():\n    # Non-compliant - print statement left in the code\n    print(\"Debug info\")\n\n@external\ndef production_function():\n    # This function is compliant as it doesn't contain print statements\n    pass\n</code></pre> <p>The <code>debug_function</code> would be flagged by this rule because it contains a <code>print</code> statement.</p>"},{"location":"rules/storage-caching/","title":"Cache Storage Variable","text":"Property Value Rule Code <code>NTX7</code> Severity Optimization <p>Experimental Rule</p> <p>This rule is currently experimental and not enabled by default. It is available in the codebase for testing purposes but is not yet production-ready.</p>"},{"location":"rules/storage-caching/#background","title":"Background","text":"<p>Reading from storage is one of the most gas-expensive operations in Vyper (and Ethereum in general). Caching storage variables in memory when they are accessed multiple times can significantly reduce gas costs.</p>"},{"location":"rules/storage-caching/#purpose","title":"Purpose","text":"<p>Detects when a storage variable is accessed multiple times in a function and suggests caching it to save gas.</p>"},{"location":"rules/storage-caching/#example","title":"Example","text":"<pre><code># Storage variable\nuser_balance: public(uint256)\n\n# Non-compliant - accessing storage variable multiple times\n@external\ndef process_balance() -&gt; uint256:\n    if self.user_balance &gt; 100:\n        return self.user_balance - 100\n    else:\n        return self.user_balance\n\n# Compliant - caching storage variable\n@external\ndef process_balance_cached() -&gt; uint256:\n    balance_cache: uint256 = self.user_balance\n    if balance_cache &gt; 100:\n        return balance_cache - 100\n    else:\n        return balance_cache\n</code></pre> <p>The <code>process_balance</code> function would be flagged by this rule because it accesses <code>self.user_balance</code> multiple times. The <code>process_balance_cached</code> function is compliant because it caches the storage variable.</p>"},{"location":"rules/unused-argument/","title":"Unused Argument","text":"Property Value Rule Code <code>NTX10</code> Severity Warning"},{"location":"rules/unused-argument/#background","title":"Background","text":"<p>Unused arguments can indicate mistakes in the code (forgotten logic) or unnecessary parameters that increase complexity and gas costs.</p>"},{"location":"rules/unused-argument/#purpose","title":"Purpose","text":"<p>Detects function arguments that are declared but never used within the function.</p>"},{"location":"rules/unused-argument/#example","title":"Example","text":"<pre><code># Non-compliant - argument '_unused' is never used in the function\n@external\ndef process(_value: uint256, _unused: address) -&gt; uint256:\n    return _value * 2\n\n# Compliant - all arguments are used\n@external\ndef process_fixed(_value: uint256, _modifier: uint256) -&gt; uint256:\n    return _value * _modifier\n</code></pre> <p>The <code>process</code> function would be flagged by this rule because the <code>_unused</code> argument is declared but never used within the function.</p>"},{"location":"rules/unused-event/","title":"Unused Event","text":"Property Value Rule Code <code>NTX13</code> Severity Warning"},{"location":"rules/unused-event/#background","title":"Background","text":"<p>Events are an essential part of smart contract development for monitoring on-chain activity. Defining events that are never emitted represents dead code and may indicate missing functionality.</p>"},{"location":"rules/unused-event/#purpose","title":"Purpose","text":"<p>This rule detects events that are defined in the contract but never emitted via <code>log</code> statements.</p>"},{"location":"rules/unused-event/#example","title":"Example","text":"<pre><code># Non-compliant code\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    amount: uint256\n\nevent Approval:  # This event is never used\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n@external\ndef transfer(to: address, amount: uint256):\n    # Only Transfer event is emitted\n    log Transfer(msg.sender, to, amount)\n\n# Compliant code\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n@external\ndef transfer(to: address, amount: uint256):\n    log Transfer(msg.sender, to, amount)\n\n@external\ndef approve(spender: address, amount: uint256):\n    log Approval(msg.sender, spender, amount)  # Now Approval is used\n</code></pre>"},{"location":"rules/unused-imports/","title":"Unused Imports","text":"Property Value Rule Code <code>NTX14</code> Severity Warning"},{"location":"rules/unused-imports/#background","title":"Background","text":"<p>Unused imports make the code harder to understand and maintain. They can mislead developers about the contract's dependencies and may indicate incomplete refactoring or copy-paste errors.</p>"},{"location":"rules/unused-imports/#purpose","title":"Purpose","text":"<p>This rule detects import statements that are never referenced in the contract code.</p>"},{"location":"rules/unused-imports/#example","title":"Example","text":"<pre><code># Non-compliant code\nfrom ethereum.ercs import IERC20  # Warning: Import 'IERC20' is not used\nfrom ethereum.ercs import IERC721  # Warning: Import 'IERC721' is not used\n\ncounter: uint256\n\n@external\ndef increment():\n    self.counter += 1\n\n# Compliant code\nfrom ethereum.ercs import IERC20\n\ntoken: IERC20\n\n@external\ndef set_token(addr: address):\n    self.token = IERC20(addr)\n</code></pre>"},{"location":"rules/unused-variable/","title":"Unused Variable","text":"Property Value Rule Code <code>NTX8</code> Severity Warning"},{"location":"rules/unused-variable/#background","title":"Background","text":"<p>Unused variables can indicate mistakes in the code (forgotten logic) or unnecessary code that increases complexity and gas costs.</p>"},{"location":"rules/unused-variable/#purpose","title":"Purpose","text":"<p>Detects variables that are declared but never used within a function.</p>"},{"location":"rules/unused-variable/#example","title":"Example","text":"<pre><code>@external\ndef process_data(_value: uint256) -&gt; uint256:\n    # Non-compliant - variable declared but never used\n    temp: uint256 = _value * 2\n\n    return _value\n\n@external\ndef process_data_fixed(_value: uint256) -&gt; uint256:\n    # Compliant - all declared variables are used\n    temp: uint256 = _value * 2\n\n    return temp\n</code></pre> <p>The <code>process_data</code> function would be flagged by this rule because the <code>temp</code> variable is declared but never used.</p>"},{"location":"rules/unused-variable/#intentionally-unused-variables-in-for-loops","title":"Intentionally Unused Variables in For Loops","text":"<p>When you need to iterate a specific number of times but don't actually use the loop variable, you can use the underscore (<code>_</code>) convention to indicate that the variable is intentionally unused. This prevents the linter from reporting it as an unused variable.</p> <pre><code>@external\ndef repeat_operation(count: uint256):\n    # Non-compliant - 'i' is declared but never used\n    for i: uint256 in range(count):\n        # Some operation that doesn't use 'i'\n        pass\n\n@external\ndef repeat_operation_fixed(count: uint256):\n    # Compliant - using '_' indicates intentionally unused variable\n    for _: uint256 in range(count):\n        # Some operation that doesn't use the loop variable\n        pass\n</code></pre> <p>By naming the loop variable <code>_</code>, you signal to both the linter and other developers that the variable is intentionally unused, preventing false positive warnings.</p>"}]}